<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="author" content="Anthony Cohn-Richardby">
  <title>Home</title>
  <link rel="stylesheet" type="text/css" href="../style.css">
</head>


<body>
<!--Wrapper-->
<div id="wrapper">

<!--main banner + sub banner with page name/summary-->
  <header>
  <!--Nav: Degree info/game/contact page/accessibility page-->
    <nav>
    <ul>
	  <li><a href="../index.html" accesskey="1">Home</a></li>
	  <li><a href="index.html" accesskey="2">Overview</a></li>
	  <li><a href="year1.html" accesskey="3">Year 1</a></li>
	  <li class="current"><a href="year2.html" accesskey="4">Year 2</a></li>
	  <li><a href="year3.html" accesskey="6">Year 3</a></li>
	</ul>
    </nav>
    <h1 id="title">Anthony Cohn-Richardby <br/>iOS Developer <br/>Former Student at the University of Sheffield</h1>
    <h1 id="subtitle">Year 2</h1>
    <p><q>... beer results in ideas, which results in new code.</q> - Theo de Raadt</p>
  </header>
  
  
  
<!--article: 2nd year-->
  <article>
    <!-- intro -->
	<p>
	  The second year introduces some really interesting stuff, our team working and management skills were sharpened with the software hut project, and the experience of working with a real client was great, although scope drift was a real issue. Learning three new languages, two of which were unlike anything seen before, was also exciting, I especially enjoyed programming in Haskell. Data driven computing was probably my favorite of the modules this year, due to the power of the techniques taught.
	</p>
	<!-- Adv prog -->
	<h2>Advanced Programming</h2>
	<p>
	  The first half of this module introduced us to two new programming paradigms, functional programming in Haskell. It was certainly very fun to learn a completely different language to anything I had ever used before. I enjoyed using Haskell a lot, the things you can do with relatively little code is great. The second half focused on analyzing code complexity, and proving program correctness using different types of induction (standard, strong and structural). This half also covered abstract data types, and dynamic programming.
	</p>
	<!-- Human Centered -->
	<h2>Human Centered Design</h2>
	<p>
	  This module covered quite a few things, starting out with human computer interaction (HCI), which taught how to create usable interfaces, and how to interact with customers. It then went on to cover more software development skills, including techniques for project management, and different methods of modeling requirements, control flow and information. Database design was also covered, which was very helpful, including data normalization and methods of ensuring your database was at least 3NF. The last part focused on experimental research methods and testing with humans, for example a usability study on an application interface and determining if your results are significant or not.
	</p>
	<!-- Automata, logic -->
	<h2>Automata, Logic, and Computation</h2>
	<p>
	  An almost entirely theory focused module, super interesting, especially learning about the very real limitations to what computers can and can’t do. Starting by introducing us to different theoretical models of computation, including finite automata, deterministic and non-deterministic, regular expressions, and their equivalent power. Context free grammars and deterministic Turing machines was also looked at. After looking at these different models, we looked at their limitations and the different classes of problems, including their relationships. The second half gave a more formal coverage of propositional and predicate logic, and how to reason using natural deduction, later introducing us to programming in Prolog.
	</p>
	<!-- Data driven-->
	<h2>Data Driven Computing</h2>
	<p>
	  Data Driven Computing seemed to pick up from where the first semester of Machines and Intelligence left off, mainly focusing on classification methods. The module started looking at linear classification and the perceptron, but then moved on to looking at the normal distribution and how this can be used to classify data. Non-parametric methods were looking into such as different types of clustering algorithm. Methods of dimensionality reduction were also examined. This module had a really rewarding assignment, in which we were asked to write a program in python capable of taking an image of a word search and solving it, this involved character recognition using principle component analysis in order to reduce the dimensionality of the data, and then passing it to a nearest neighbor classifier.
	</p>
	<!-- Bio inspired -->
	<h2>Bio-Inspired Computing</h2>
	<p>
	  A really neat module, introducing some – I thought – really strange ways of doing things. Probably the most well-known thing we studied was cellular automata, a popular example being Conway’s Game of Life. We studied genetic algorithms in addition to this. These are based upon the idea of natural selection in which the fittest survive, only instead of animals, we have solutions proposed, and these are rated based on a fitness function, and the fittest are selected to go on to the next stage. During this process solutions are mixed together, kind of like genes are during reproduction. All very cool stuff. Although this module is called bio-inspired computing, it consisted of another two components, robotics and cognition + interaction. The robotics section looked at the earliest robots and modern ones of applications in areas like warfare and health. It was interesting to learn how programmed ‘likes’ for certain senses, tropisms, can be combined to produce really complex behavior that you might associate with life such as ants. The cognition section looked at emotion and control theory, while the interaction section examined the sense of self we have, and how we learn through imitation.
	</p>
	<!-- soft hut-->
	<h2>Software Hut</h2>
	<p>
	  Really intense, lots of deadlines and a demand for teamwork. That sums this module up fairly well, I feel. We learned ruby and how to use the ruby on rails framework for rapid development, how to extract requirements from client meetings. We also put into practice the things we learned about the XP (eXtreme Programming) model, making extensive use of story cards to get an overview of the key features required by the client, and then progressively gain more information, in order to develop while still learning about what the client required. Unit tests also played a big part in this module, in order to maintain a rapid development cycle while still having usable code, we had to write a bunch of unit tests and run them often. Our teams project specifically dealt with a time accounting system, required to help workers in the care for the elderly to get proper pay – as they are often under-paid for things like travel time. This is a big issue, actually, and I advise you to hit up google on the underpayment of care workers!
    </p>
  </article>

 
<!--/wrapper-->
</div>
<!--footer: author/last updated-->
<footer>
    <p>Written and designed by Anthony Cohn-Richardby. Last updated 2016.</p>
</footer>
 
</body>


</html>
